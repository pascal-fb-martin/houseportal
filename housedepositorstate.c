/* houseportal - A simple web portal for home servers
 *
 * Copyright 2020, Pascal Martin
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * housedepositorstate.c - Client to backup and restore application state.
 *
 * A state file in HouseDepot covers data items that were automatically
 * generated by the application and not manually set by the user, that
 * the application needs to function as expected when it restarts.
 *
 * This module interacts with all detected HouseDepot service, to retrieve
 * the latest state file, and update all HouseDepot services when the state
 * has changed.
 *
 * This version uses both the local backup file _and_ the data from the
 * depot repository. The later has priority. This scheme has two benefits:
 * - seamless transition from local storage only to depot repositories.
 * - keep working even if the depot is not accessible.
 *
 * SYNOPSYS:
 *
 * void housedepositor_state_share (int on);
 *
 *    Turn the depot mechanism on and off. The intent is to turn it
 *    on only when the application is active. This way, if the application
 *    runs on multiple server but only one is active, the non-active instances
 *    will not record their state, but load the state of the active instance.
 *
 *    The default is to not share.
 *
 * void housedepositor_state_listen (BackupListener *listener);
 *
 *    Listen to external changes to the state backup. Such changes typically
 *    come from the depot repository.
 *
 * void housedepositor_state_register (BackupWorker *worker);
 *
 *    Register a worker function to export a module's internal state to JSON.
 *    Worker functions are called when the state must be saved.
 *
 *    Modules that need to backup data must use this to register a worker
 *    function that exports the module's internal state to a JSON structure
 *    that will be saved to disk (local or depot repository)..
 *
 * long housedepositor_state_get (const char *path);
 * const char *housedepositor_state_get_string (const char *path);
 *
 *    Retrieve items from the state backup file. This backup file contains
 *    saved live values that can be changed from the user interface and must
 *    survive a program restart. Supported data types are boolean, integer and
 *    string (for now). A boolean is reported as an integer (0 or 1).
 *
 * void housedepositor_state_changed (void);
 *
 *    Report that the internal state has changed.
 *
 *    Note that saving the backup data is asynchronous: the client indicates
 *    that the data has changed, but saving the data will be decided later.
 *    The reason for this is that multiple clients might change their data
 *    at around the same time, but we do not want to save each time: it is
 *    better to delay and do the save only once.
 *
 * void housedepositor_state_load (const char *app, int argc, const char **argv);
 *
 *    Initial state load when the software starts.
 *
 * void housedepositor_state_background (time_t now);
 *
 *    Background state activity (mostly: save or reload data when changed).
 */

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <echttp.h>
#include <echttp_json.h>

#include "houselog.h"
#include "housedepositor.h"
#include "housedepositorstate.h"

#define DEBUG if (echttp_isdebug()) printf

static ParserToken *BackupParsed = 0;
static int   BackupTokenAllocated = 0;
static int   BackupTokenCount = 0;
static char *BackupInText = 0;

static const char *BackupDepotFormat = "%s.json";

static const char *BackupFileFormat = "/etc/house/%s.json";

static const char FactoryBackupFileFormat[] =
                      "/usr/local/share/house/public/%s/backup.json";

static const char *BackupFile = 0;
static const char *FactoryBackupFile = 0;
static const char *BackupDepot = 0;

static time_t StateDataHasChanged = 0;

static int ShareStateData = 0;
static int StateFileEnabled = 1;

static char *BackupOutBuffer = 0;
static int BackupOutBufferSize = 0;

// The backup mechanism relies on collaboration from the modules that
// need to backup data: only these modules know what data is to be saved.
//
static BackupListener **BackupRegisteredListener = 0;
static int BackupListenerSize = 0;
static int BackupListenerCount = 0;

void housedepositor_state_listen (BackupListener *listener) {

    int i;
    if (! listener) return; // Just a check against gross error.
    for (i = 0; i < BackupListenerCount; ++i) {
        if (BackupRegisteredListener[i] == listener)
            return; // Already registered.
    }
    if (BackupListenerCount >= BackupListenerSize) {
        BackupListenerSize += 16;
        BackupRegisteredListener =
            realloc (BackupRegisteredListener,
                     sizeof(BackupListener *) * BackupListenerSize);
    }
    BackupRegisteredListener[BackupListenerCount++] = listener;
}

static BackupWorker **BackupRegisteredWorker = 0;
static int BackupWorkerSize = 0;
static int BackupWorkerCount = 0;

void housedepositor_state_register (BackupWorker *worker) {

    int i;
    if (! worker) return; // Just a check against gross error.
    for (i = 0; i < BackupWorkerCount; ++i) {
        if (BackupRegisteredWorker[i] == worker) return; // Already registered.
    }
    if (BackupWorkerCount >= BackupWorkerSize) {
        BackupWorkerSize += 16;
        BackupRegisteredWorker =
            realloc (BackupRegisteredWorker,
                     sizeof(BackupWorker *) * BackupWorkerSize);
    }
    BackupRegisteredWorker[BackupWorkerCount++] = worker;
}

static void housedepositor_state_clear (void) {
    if (BackupInText) {
        echttp_parser_free (BackupInText);
        BackupInText = 0;
    }
    BackupTokenCount = 0;
}

static const char *housedepositor_state_new (char *data) {

    const char *error;

    BackupInText = data;
    BackupTokenCount = echttp_json_estimate(BackupInText);
    if (BackupTokenCount > BackupTokenAllocated) {
        BackupTokenAllocated = BackupTokenCount+64;
        if (BackupParsed) free (BackupParsed);
        BackupParsed = calloc (BackupTokenAllocated, sizeof(ParserToken));
    }
    error = echttp_json_parse (BackupInText, BackupParsed, &BackupTokenCount);
    if (error) {
        DEBUG ("Backup config parsing error: %s\n", error);
        housedepositor_state_clear ();
    } else {
        DEBUG ("Planned %d, read %d items of backup config\n", BackupTokenAllocated, BackupTokenCount);
    }
    return error;
}

static int housedepositor_state_save (int size) {

    if (!StateFileEnabled) return size; // No error.

    int fd = open (BackupFile, O_WRONLY|O_TRUNC|O_CREAT, 0777);
    if (fd < 0) {
        DEBUG ("Cannot open %s\n", BackupFile);
        return 0; // Failure.
    }
    int written = write (fd, BackupOutBuffer, size);
    if (written < 0) {
        DEBUG ("Cannot write to %s\n", BackupFile);
    } else {
        DEBUG ("Wrote %d characters to %s\n", written, BackupFile);
    }
    close(fd);
    return written;
}

static void housedepositor_state_listener (const char *name, time_t timestamp,
                                           const char *data, int length) {

    houselog_event ("SYSTEM", "STATE", "LOAD", "FROM DEPOT %s", name);
    const char *error = housedepositor_state_new (echttp_parser_string(data));
    if (error) {
        houselog_event ("SYSTEM", "STATE", "ERROR", "%s", error);
        return;
    }
    // We need to make a copy because we do not control the lifetime of
    // the caller's data buffer.
    //
    if (BackupOutBufferSize < length) {
        if (BackupOutBuffer) free (BackupOutBuffer);
        BackupOutBuffer = strdup (data);
        BackupOutBufferSize = length;
    } else {
        snprintf (BackupOutBuffer, BackupOutBufferSize, "%s", data);
    }
    housedepositor_state_save (length); // Best effort only, ignore errors.

    int i;
    for (i = 0; i < BackupListenerCount; ++i) {
        BackupRegisteredListener[i] ();
    }
}

void housedepositor_state_load (const char *app, int argc, const char **argv) {

    int i;
    for (i = 1; i < argc; ++i) {
        if (echttp_option_match ("-backup=", argv[i], &BackupFile)) continue;
        if (echttp_option_present ("-no-local-storage", argv[i])) {
            StateFileEnabled = 0;
            continue;
        }
    }

    char buffer[512];
    snprintf (buffer, sizeof(buffer), BackupDepotFormat, app);
    BackupDepot = strdup (buffer);
    if (!BackupFile) {
        snprintf (buffer, sizeof(buffer), BackupFileFormat, app);
        BackupFile = strdup (buffer);
    }
    snprintf (buffer, sizeof(buffer), FactoryBackupFileFormat, app);
    FactoryBackupFile = strdup (buffer);

    housedepositor_state_clear ();

    housedepositor_subscribe ("state", BackupDepot, housedepositor_state_listener);

    if (!StateFileEnabled) return;

    const char *name = BackupFile;
    char *newconfig = echttp_parser_load (name);
    if (!newconfig) {
        name = FactoryBackupFile;
        newconfig = echttp_parser_load (name);
    }

    if (newconfig) {
        DEBUG ("Loaded backup state from %s\n", name);
        houselog_event ("SYSTEM", "STATE", "LOAD", "FILE %s", name);
        housedepositor_state_new (newconfig);
    }
}

void housedepositor_state_share (int on) {
    ShareStateData = on;
}

const char *housedepositor_state_get_string (const char *path) {

    if (BackupTokenCount <= 0) return 0;

    int i = echttp_json_search(BackupParsed, path);
    if (i < 0) return 0;
    switch (BackupParsed[i].type) {
        case PARSER_STRING: return BackupParsed[i].value.string;
    }
    return 0;
}

long housedepositor_state_get (const char *path) {

    if (BackupTokenCount <= 0) return 0;

    // Support boolean and integer, all converted to integer.
    // Anything else: return 0
    //
    long value = 0;
    int i = echttp_json_search(BackupParsed, path);
    if (i < 0) return 0;
    switch (BackupParsed[i].type) {
        case PARSER_BOOL: value = BackupParsed[i].value.bool; break;
        case PARSER_INTEGER: value = BackupParsed[i].value.integer; break;
    }
    return value;
}

void housedepositor_state_changed (void) {
    if (!StateDataHasChanged) {
        DEBUG("State data has changed.\n");
        StateDataHasChanged = time(0);
    }
}

static const char *housedepositor_state_host(void) {
    static char HostName[256];
    if (HostName[0] == 0) {
        gethostname (HostName, sizeof(HostName));
    }
    return HostName;
}

static int housedepositor_state_format (void) {

    int cursor = 0;
    int i;
    if (!BackupOutBuffer) {
       BackupOutBufferSize = 1024;
       BackupOutBuffer = malloc(BackupOutBufferSize);
    }
    DEBUG("Saving backup data to %s\n", BackupFile);
    cursor = snprintf (BackupOutBuffer, BackupOutBufferSize,
                       "{\"host\":\"%s\"", housedepositor_state_host());
    for (i = 0; i < BackupWorkerCount; ++i) {
        cursor += BackupRegisteredWorker[i] (BackupOutBuffer+cursor, BackupOutBufferSize-cursor);
        if (cursor >= BackupOutBufferSize) goto retry;
    }
    cursor += snprintf (BackupOutBuffer+cursor, BackupOutBufferSize-cursor, "}");
    if (cursor >= BackupOutBufferSize) goto retry;

    return cursor;

retry:
    DEBUG ("Backup failed: buffer too small\n");
    houselog_trace (HOUSE_WARNING, "STATE",
                    "BUFFER TOO SMALL (NEED %d bytes)", cursor);
    BackupOutBufferSize += 1024;
    BackupOutBuffer = realloc(BackupOutBuffer, BackupOutBufferSize);
    return housedepositor_state_format ();
}

void housedepositor_state_background (time_t now) {

    static time_t LastCall = 0;
    if (now == LastCall) return; // Run the logic once per second.
    LastCall = now;

    // Delay saving any state for after the first 30 seconds. This gives
    // the application some time to reach a stable state.
    //
    static time_t StabilityPeriodEnd = 0;
    if (StabilityPeriodEnd == 0) StabilityPeriodEnd = now + 30;
    if (now < StabilityPeriodEnd) {
        if (StateDataHasChanged) StateDataHasChanged = now; // Renew.
        return;
    }

    if (StateDataHasChanged) {
        if (StateDataHasChanged + 20 < now) {
            // We tried 10 times, no point to try again.
            StateDataHasChanged = 0;
            return;
        }
        // Delay saving state by a few seconds, to avoid saving an unstable
        // state.
        if (StateDataHasChanged + 10 <= now) {
            int size = housedepositor_state_format();
            if (size <= 0) return;
            if (ShareStateData) {
                houselog_event ("SYSTEM", "STATE", "SAVE",
                                "TO DEPOT %s", BackupDepot);
                housedepositor_put ("state", BackupDepot,
                                    BackupOutBuffer, size);
            }
            if (housedepositor_state_save (size) == size)
                StateDataHasChanged = 0;
        }
    }
}

